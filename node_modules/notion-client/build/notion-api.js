"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// import { promises as fs } from 'fs'
const got_1 = __importDefault(require("got"));
const p_map_1 = __importDefault(require("p-map"));
const notion_utils_1 = require("notion-utils");
class NotionAPI {
    constructor({ apiBaseUrl = 'https://www.notion.so/api/v3', authToken, userLocale = 'en', userTimeZone = 'America/New_York' } = {}) {
        this._apiBaseUrl = apiBaseUrl;
        this._authToken = authToken;
        this._userLocale = userLocale;
        this._userTimeZone = userTimeZone;
    }
    getPage(pageId, { concurrency = 3, fetchCollections = true, signFileUrls = true } = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.getPageRaw(pageId);
            const recordMap = page.recordMap;
            if (!recordMap.block) {
                throw new Error(`Notion page not found "${pageId}"`);
            }
            // ensure that all top-level maps exist
            recordMap.collection = (_a = recordMap.collection, (_a !== null && _a !== void 0 ? _a : {}));
            recordMap.collection_view = (_b = recordMap.collection_view, (_b !== null && _b !== void 0 ? _b : {}));
            recordMap.notion_user = (_c = recordMap.notion_user, (_c !== null && _c !== void 0 ? _c : {}));
            // additional mappings added for convenience
            // note: these are not native notion objects
            recordMap.collection_query = {};
            recordMap.signed_urls = {};
            // fetch any missing content blocks
            while (true) {
                const pendingBlockIds = notion_utils_1.getPageContentBlockIds(recordMap).filter((id) => !recordMap.block[id]);
                if (!pendingBlockIds.length) {
                    break;
                }
                const newBlocks = yield this.getBlocks(pendingBlockIds).then((res) => res.recordMap.block);
                recordMap.block = Object.assign(Object.assign({}, recordMap.block), newBlocks);
            }
            const contentBlockIds = notion_utils_1.getPageContentBlockIds(recordMap);
            // Optionally fetch all data for embedded collections and their associated views.
            // NOTE: We're eagerly fetching *all* data for each collection and all of its views.
            // This is really convenient in order to ensure that all data needed for a given
            // Notion page is readily available for use cases involving server-side rendering
            // and edge caching.
            if (fetchCollections) {
                const allCollectionInstances = contentBlockIds.flatMap((blockId) => {
                    const block = recordMap.block[blockId].value;
                    if (block &&
                        (block.type === 'collection_view' ||
                            block.type === 'collection_view_page')) {
                        return block.view_ids.map((collectionViewId) => ({
                            collectionId: block.collection_id,
                            collectionViewId
                        }));
                    }
                    else {
                        return [];
                    }
                });
                // fetch data for all collection view instances
                yield p_map_1.default(allCollectionInstances, (collectionInstance) => __awaiter(this, void 0, void 0, function* () {
                    var _d, _e, _f, _g, _h, _j, _k, _l;
                    const { collectionId, collectionViewId } = collectionInstance;
                    const collectionView = (_d = recordMap.collection_view[collectionViewId]) === null || _d === void 0 ? void 0 : _d.value;
                    try {
                        const collectionData = yield this.getCollectionData(collectionId, collectionViewId, {
                            type: (_e = collectionView) === null || _e === void 0 ? void 0 : _e.type,
                            query: ((_f = collectionView) === null || _f === void 0 ? void 0 : _f.query2) || ((_g = collectionView) === null || _g === void 0 ? void 0 : _g.query),
                            groups: ((_j = (_h = collectionView) === null || _h === void 0 ? void 0 : _h.format) === null || _j === void 0 ? void 0 : _j.board_groups2) || ((_l = (_k = collectionView) === null || _k === void 0 ? void 0 : _k.format) === null || _l === void 0 ? void 0 : _l.board_groups)
                        });
                        // await fs.writeFile(
                        //   `${collectionId}-${collectionViewId}.json`,
                        //   JSON.stringify(collectionData.result, null, 2)
                        // )
                        recordMap.block = Object.assign(Object.assign({}, recordMap.block), collectionData.recordMap.block);
                        recordMap.collection = Object.assign(Object.assign({}, recordMap.collection), collectionData.recordMap.collection);
                        recordMap.collection_view = Object.assign(Object.assign({}, recordMap.collection_view), collectionData.recordMap.collection_view);
                        recordMap.notion_user = Object.assign(Object.assign({}, recordMap.notion_user), collectionData.recordMap.notion_user);
                        recordMap.collection_query[collectionId] = Object.assign(Object.assign({}, recordMap.collection_query[collectionId]), { [collectionViewId]: collectionData.result });
                    }
                    catch (err) {
                        // It's possible for public pages to link to private collections, in which case
                        // Notion returns a 400 error
                        console.warn('NotionAPI collectionQuery error', err.message);
                    }
                }), {
                    concurrency
                });
            }
            // Optionally fetch signed URLs for any embedded files.
            // NOTE: Similar to collection data, we default to eagerly fetching signed URL info
            // because it is preferable for many use cases as opposed to making these API calls
            // lazily from the client-side.
            if (signFileUrls) {
                const allFileInstances = contentBlockIds.flatMap((blockId) => {
                    var _a, _b, _c;
                    const block = recordMap.block[blockId].value;
                    if (block &&
                        (block.type === 'pdf' ||
                            block.type === 'audio' ||
                            block.type === 'file')) {
                        const source = (_c = (_b = (_a = block.properties) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c[0];
                        if (source) {
                            return {
                                permissionRecord: {
                                    table: 'block',
                                    id: block.id
                                },
                                url: source
                            };
                        }
                    }
                    return [];
                });
                if (allFileInstances.length > 0) {
                    try {
                        const { signedUrls } = yield this.getSignedFileUrls(allFileInstances);
                        if (signedUrls.length === allFileInstances.length) {
                            for (let i = 0; i < allFileInstances.length; ++i) {
                                const file = allFileInstances[i];
                                const signedUrl = signedUrls[i];
                                recordMap.signed_urls[file.permissionRecord.id] = signedUrl;
                            }
                        }
                    }
                    catch (err) {
                        console.warn('NotionAPI getSignedfileUrls error', err);
                    }
                }
            }
            return recordMap;
        });
    }
    getPageRaw(pageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedPageId = notion_utils_1.parsePageId(pageId);
            if (!parsedPageId) {
                throw new Error(`invalid notion pageId "${pageId}"`);
            }
            return this.fetch({
                endpoint: 'loadPageChunk',
                body: {
                    pageId: parsedPageId,
                    limit: 999999,
                    cursor: { stack: [] },
                    chunkNumber: 0,
                    verticalColumns: false
                }
            });
        });
    }
    getCollectionData(collectionId, collectionViewId, { type = 'table', query = { aggregations: [{ property: 'title', aggregator: 'count' }] }, groups = undefined, limit = 999999, searchQuery = '', userTimeZone = this._userTimeZone, userLocale = this._userLocale, loadContentCover = true } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: All other collection types queries fail with 400 errors.
            // My guess is that they require slightly different query params, but since
            // their results are the same AFAICT, there's not much point in supporting
            // them.
            if (type !== 'table' && type !== 'board') {
                type = 'table';
            }
            const loader = {
                type,
                limit,
                searchQuery,
                userTimeZone,
                userLocale,
                loadContentCover
            };
            if (groups) {
                // used for 'board' collection view queries
                loader.groups = groups;
            }
            // useful for debugging collection queries
            // console.log(JSON.stringify('queryCollection', { collectionId, collectionViewId, query, loader }, null, 2))
            return this.fetch({
                endpoint: 'queryCollection',
                body: {
                    collectionId,
                    collectionViewId,
                    query,
                    loader
                }
            });
        });
    }
    getUsers(userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch({
                endpoint: 'getRecordValues',
                body: {
                    requests: userIds.map((id) => ({ id, table: 'notion_user' }))
                }
            });
        });
    }
    getBlocks(blockIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch({
                endpoint: 'syncRecordValues',
                body: {
                    recordVersionMap: {
                        block: blockIds.reduce((acc, blockId) => (Object.assign(Object.assign({}, acc), { [blockId]: -1 })), {})
                    }
                }
            });
        });
    }
    getSignedFileUrls(urls) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch({
                endpoint: 'getSignedFileUrls',
                body: {
                    urls
                }
            });
        });
    }
    search(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch({
                endpoint: 'search',
                body: {
                    type: 'BlocksInAncestor',
                    source: 'quick_find_public',
                    ancestorId: params.ancestorId,
                    filters: Object.assign({ isDeletedOnly: false, excludeTemplates: true, isNavigableOnly: true, requireEditPermissions: false, ancestors: [], createdBy: [], editedBy: [], lastEditedTime: {}, createdTime: {} }, params.filters),
                    sort: 'Relevance',
                    limit: params.limit || 20,
                    query: params.query
                }
            });
        });
    }
    fetch({ endpoint, body }) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (this._authToken) {
                headers.cookie = `token_v2=${this._authToken}`;
            }
            return got_1.default
                .post(endpoint, {
                prefixUrl: this._apiBaseUrl,
                json: body,
                headers
            })
                .json();
        });
    }
}
exports.NotionAPI = NotionAPI;
//# sourceMappingURL=notion-api.js.map