"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const date_fns_1 = require("date-fns");
const get_text_content_1 = require("./get-text-content");
const get_date_value_1 = require("./get-date-value");
/**
 * Evaluates a Notion formula expression to a result value.
 *
 * All built-in functions and operators are supported.
 *
 * NOTE: this needs a lot more testing, especially around covering all the different
 * function types and coercing different property values correctly.
 *
 * It does work for many of our test cases, however.
 *
 * @param formula - Formula to evaluate.
 * @param context - Collection context containing property schema and values.
 */
function evalFormula(formula, context) {
    var _a, _b;
    const { endDate } = context, ctx = __rest(context
    // TODO: coerce return type using `formula.return_type`
    , ["endDate"]);
    // TODO: coerce return type using `formula.return_type`
    switch ((_a = formula) === null || _a === void 0 ? void 0 : _a.type) {
        case 'symbol':
            // TODO: this isn't documented anywhere but seen in the wild
            return formula.name === 'true';
        case 'constant': {
            const value = formula.value;
            switch (formula.result_type) {
                case 'text':
                    return value;
                case 'number':
                    return parseFloat(value);
                default:
                    return value;
            }
        }
        case 'property':
            const value = ctx.properties[formula.id];
            const text = get_text_content_1.getTextContent(value);
            switch (formula.result_type) {
                case 'text':
                    return text;
                case 'number':
                    return parseFloat(text);
                case 'boolean':
                    // TODO: handle chceckbox properties
                    if (typeof text === 'string') {
                        return text === 'true';
                    }
                    else {
                        return !!text;
                    }
                case 'date':
                    // console.log('date', text, value)
                    const v = get_date_value_1.getDateValue(value);
                    if (v) {
                        if (endDate && v.end_date) {
                            return new Date(v.end_date);
                        }
                        else {
                            return new Date(v.start_date);
                        }
                    }
                    else {
                        return new Date(text);
                    }
                default:
                    return text;
            }
        case 'operator':
        // All operators are exposed as functions, so we handle them the same
        case 'function':
            return evalFunctionFormula(formula, ctx);
        default:
            console.log(formula);
            throw new Error(`invalid or unsupported formula "${(_b = formula) === null || _b === void 0 ? void 0 : _b.type}`);
    }
}
exports.evalFormula = evalFormula;
/**
 * Evaluates a Notion formula function or operator expression.
 *
 * Note that all operators are also exposed as functions, so we handle them the same.
 *
 * @private
 */
function evalFunctionFormula(formula, ctx) {
    var _a, _b;
    const args = (_a = formula) === null || _a === void 0 ? void 0 : _a.args;
    switch (formula.name) {
        // logic
        // ------------------------------------------------------------------------
        case 'and':
            return evalFormula(args[0], ctx) && evalFormula(args[1], ctx);
        case 'empty':
            return !evalFormula(args[0], ctx);
        case 'equal':
            return evalFormula(args[0], ctx) == evalFormula(args[1], ctx);
        case 'if':
            return evalFormula(args[0], ctx)
                ? evalFormula(args[1], ctx)
                : evalFormula(args[2], ctx);
        case 'larger':
            return evalFormula(args[0], ctx) > evalFormula(args[1], ctx);
        case 'largerEq':
            return evalFormula(args[0], ctx) >= evalFormula(args[1], ctx);
        case 'not':
            return !evalFormula(args[0], ctx);
        case 'or':
            return evalFormula(args[0], ctx) || evalFormula(args[1], ctx);
        case 'smaller':
            return evalFormula(args[0], ctx) < evalFormula(args[1], ctx);
        case 'smallerEq':
            return evalFormula(args[0], ctx) <= evalFormula(args[1], ctx);
        case 'unequal':
            return evalFormula(args[0], ctx) != evalFormula(args[1], ctx);
        // numeric
        // ------------------------------------------------------------------------
        case 'abs':
            return Math.abs(evalFormula(args[0], ctx));
        case 'add':
            const v0 = evalFormula(args[0], ctx);
            const v1 = evalFormula(args[1], ctx);
            if (typeof v0 === 'number') {
                return v0 + +v1;
            }
            else if (typeof v0 === 'string') {
                return v0 + `${v1}`;
            }
            else {
                // TODO
                return v0;
            }
        case 'cbrt':
            return Math.cbrt(evalFormula(args[0], ctx));
        case 'ceil':
            return Math.ceil(evalFormula(args[0], ctx));
        case 'divide':
            return (evalFormula(args[0], ctx) /
                evalFormula(args[1], ctx));
        case 'exp':
            return Math.exp(evalFormula(args[0], ctx));
        case 'floor':
            return Math.floor(evalFormula(args[0], ctx));
        case 'ln':
            return Math.log(evalFormula(args[0], ctx));
        case 'log10':
            return Math.log10(evalFormula(args[0], ctx));
        case 'log2':
            return Math.log2(evalFormula(args[0], ctx));
        case 'max':
            const values = args.map((arg) => evalFormula(arg, ctx));
            return values.reduce((acc, value) => Math.max(acc, value), Number.NEGATIVE_INFINITY);
        case 'min': {
            const values = args.map((arg) => evalFormula(arg, ctx));
            return values.reduce((acc, value) => Math.min(acc, value), Number.POSITIVE_INFINITY);
        }
        case 'mod':
            return (evalFormula(args[0], ctx) %
                evalFormula(args[1], ctx));
        case 'multiply':
            return (evalFormula(args[0], ctx) *
                evalFormula(args[1], ctx));
        case 'pow':
            return Math.pow(evalFormula(args[0], ctx), evalFormula(args[1], ctx));
        case 'round':
            return Math.round(evalFormula(args[0], ctx));
        case 'sign':
            return Math.sign(evalFormula(args[0], ctx));
        case 'sqrt':
            return Math.sqrt(evalFormula(args[0], ctx));
        case 'subtract':
            return (evalFormula(args[0], ctx) -
                evalFormula(args[1], ctx));
        case 'toNumber':
            return parseFloat(evalFormula(args[0], ctx));
        case 'unaryMinus':
            return evalFormula(args[0], ctx) * -1;
        case 'unaryPlus':
            return parseFloat(evalFormula(args[0], ctx));
        // text
        // ------------------------------------------------------------------------
        case 'concat': {
            const values = args.map((arg) => evalFormula(arg, ctx));
            return values.join('');
        }
        case 'contains':
            return evalFormula(args[0], ctx).includes(evalFormula(args[1], ctx));
        case 'format': {
            const value = evalFormula(args[0], ctx);
            switch (typeof value) {
                case 'string':
                    return value;
                case 'object':
                    if (value instanceof Date) {
                        return date_fns_1.format(value, 'MMM d, YYY');
                    }
                    else {
                        // shouldn't ever get here
                        return `${value}`;
                    }
                case 'number':
                default:
                    return `${value}`;
            }
        }
        case 'join': {
            const [delimiterArg, ...restArgs] = args;
            const delimiter = evalFormula(delimiterArg, ctx);
            const values = restArgs.map((arg) => evalFormula(arg, ctx));
            return values.join(delimiter);
        }
        case 'length':
            return evalFormula(args[0], ctx).length;
        case 'replace':
            const value = evalFormula(args[0], ctx);
            const regex = evalFormula(args[1], ctx);
            const replacement = evalFormula(args[2], ctx);
            return value.replace(new RegExp(regex), replacement);
        case 'replaceAll': {
            const value = evalFormula(args[0], ctx);
            const regex = evalFormula(args[1], ctx);
            const replacement = evalFormula(args[2], ctx);
            return value.replace(new RegExp(regex, 'g'), replacement);
        }
        case 'slice': {
            const value = evalFormula(args[0], ctx);
            const beginIndex = evalFormula(args[1], ctx);
            const endIndex = args[2]
                ? evalFormula(args[2], ctx)
                : value.length;
            return value.slice(beginIndex, endIndex);
        }
        case 'test': {
            const value = evalFormula(args[0], ctx);
            const regex = evalFormula(args[1], ctx);
            return new RegExp(regex).test(value);
        }
        // date & time
        // ------------------------------------------------------------------------
        case 'date':
            return date_fns_1.getDate(evalFormula(args[0], ctx));
        case 'dateAdd': {
            const date = evalFormula(args[0], ctx);
            const number = evalFormula(args[1], ctx);
            const unit = evalFormula(args[1], ctx);
            return date_fns_1.add(date, { [unit]: number });
        }
        case 'dateBetween': {
            const date1 = evalFormula(args[0], ctx);
            const date2 = evalFormula(args[1], ctx);
            const unit = evalFormula(args[1], ctx);
            return date_fns_1.intervalToDuration({
                start: date2,
                end: date1
            })[unit];
        }
        case 'dateSubtract':
            const date = evalFormula(args[0], ctx);
            const number = evalFormula(args[1], ctx);
            const unit = evalFormula(args[1], ctx);
            return date_fns_1.sub(date, { [unit]: number });
        case 'day':
            return date_fns_1.getDay(evalFormula(args[0], ctx));
        case 'end':
            return evalFormula(args[0], Object.assign(Object.assign({}, ctx), { endDate: true }));
        case 'formatDate': {
            const date = evalFormula(args[0], ctx);
            const formatValue = evalFormula(args[1], ctx).replace('dddd', 'eeee');
            return date_fns_1.format(date, formatValue);
        }
        case 'fromTimestamp':
            return new Date(evalFormula(args[0], ctx));
        case 'hour':
            return date_fns_1.getHours(evalFormula(args[0], ctx));
        case 'minute':
            return date_fns_1.getMinutes(evalFormula(args[0], ctx));
        case 'month':
            return date_fns_1.getMonth(evalFormula(args[0], ctx));
        case 'now':
            return new Date();
        case 'start':
            return evalFormula(args[0], Object.assign(Object.assign({}, ctx), { endDate: false }));
        case 'timestamp':
            return evalFormula(args[0], ctx).getTime();
        case 'year':
            return date_fns_1.getYear(evalFormula(args[0], ctx));
        default:
            console.log(formula);
            throw new Error(`invalid or unsupported function formula "${(_b = formula) === null || _b === void 0 ? void 0 : _b.type}`);
    }
}
//# sourceMappingURL=eval-formula.js.map